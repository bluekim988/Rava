# day14

예외처리

**
예외처리의 목적은 프로그램의 정상적인 종료에 있다.
	
	
	==>	프로그램적으로는 문제가 없으나  (문법상 오류가 없으나)
		데이터의 문제나 장비의 문제 등에 의해서 프로그램을 실행하는도중 발생하는 에러를
			"실행 에러(Run Time Error)"라고 표현하고
		이것을 자바에서는 "예외(Exception)" 이라고 부른다.
		
		문제는
		이런 예외는 개발자가 예측해서 
		문제가 발생했을 경우 대처하는 방식으로 프로그램을 제작해야하고
		이처럼 예외가 발생했을 경우 대처하는 방식의 프로그램을
			"예외 처리"
		라고 말한다.
		
	이런 문제점(예외가 발생하는 원인)을 개발자가 알고 있어야 하기에
	자바에서는 이런 문제를 해결하기 위해서 예외처리 문법이 존재한다.
	
	형식]
		
		(1)
		try{
			(2)
			실행문
			(3)
		} catch(####) {
			(4)
			
		} [finally] {
			(5)
		}
		(6)
		
		실행순서 ]
		
			실행문이 에러가 안날 경우 : 1 - 2 - 3 - 5 - 6
			실행문이 에러가 발생할 경우 : 1 - 2 - 4 - 5 - 6
			
	문제점]
	
		(3) 이 문제인데 
		이 부분에 있는 내용은 예외가 발생하면 실행하지 않는다.
		따라서 try{}의 범위에 따라서 실행 할 수 있고, 실행되지 않을 수도 있다.
		
	예를 들어
	
		try {
			파일을 오픈하고 ==> 파일이 없으면 에러가 난다.
		}
		파일 내용을 읽는 명령 ==> 파일의 오픈 여부에 따라서 읽는 명령도 실행 여부가 판다이된다.
		
	자바의 예외처리의 원인
		예외가 발생하면 JVM은 발생한 예외의 종류를 분석한 후
		예외에 대한 정보를 자바스럽게 클래스로 만들어 준뒤
		catch{} 에 예외를 알려준다.
		
	catch 의 의미
		==> 예외가 발생하면 그 예외의 정보를 받아서
			개발자가 그 정보를 이용해서 원하는 처리를 해줘야 한다.
			
	다중 catch  (참고로 if - else if - else 구문 참고)
		==>
			try {} 안에 여러명령행 들이 여러가지 복합적인 예외 발생 요소를 가질 수있다.
		
			이 때 반드시 어떤 에러 때문인지를 구분해야 한다면???
			이런 경우를 대비해서 만들어 놓은 방법이다.
			
		형식]
		
			try{
			
			} catch() {
			
			} 
			} catch() {
			
			} 
			} catch() {
			
			} 
		
		주의 사항]
			
			다중 catch 를 사용하는 경우
			반드시 실행 될 수 있는 상태로 만들어야 한다.
			==> 예외의 범위가 좁은 쪽부터 기술해야 한다.
		
------------------------------------------------------------
	문제 2]
	
		if - else if 구문을 사용해서
		
		나이를 입력하면 십대, 이십대, ...
		판별해주는 프로그램을 작성하세요.
		
------------------------------------------------------------		
		
finally 블럭
	==> 예외 발생 여부에 관계없이 반드시 실행되어야 할 명령이 존재할 경우
		이런 문장들을 입력하는 블럭
		
	참고]
		만약 finally 블럭이 존재한다면 catch 블럭을 생략해도 무방하다.
		(실재 실무에서는 catch 블럭을 생략안한다.)
		
예외 정보 출력하기
	==> 다음 이유에 의해서 예외 정보를 얻을 수 있다.
	
		1. 예외정보클래스의 변수를 출력하면 된다.
			
			예 ]
				System.out.println(예외정보클래스변수);
				==> 예외의 원인을 파악할 수 있게 된다.
		
		2. 변수.printStackTrace() 를 이용하는 방법
			==> 예외의 정보 + 예외가 발생하게된 위치와 경로를
				추적해서 출력해준다.
				
		3. 변수.getMessage()
			
	우리가 앞에서 예외처리는
	예외가 발생하면 개발자가 그것을 수정해서
	정상적으로 동작하도록 만드는 행위라고 정의 했다.
	하지만 정상적으로 동작하도록 만드는 행위를 한다는 것은
	매우 어려운 일이며, 그 경우는 많지 않다.
	
	다만 예외처리를 하는 실제 이유는 
	예외 정보를 알아서 사용자에게 프로그램에 문제가 왜 생겼는지를 알려주고
	그 프로그램을 정상적으로 종료되도록 하는 것을 목적으로 갖는 경우가 많다.			
		
------------------------------------------------------------

예외 전이하기
	==> 함수는 프로그램의 가장 작은 단위로 한가지 작업을 하기 위해서 만드는 것이다.
		따라서 함수 안에서 작업을 하다가 예외가 발생하면
		그 함수는 더이상 실행할 필요가 없는 경우가 많다.
		
		따라서 함수는 예외를 전이하도록 해 놓은 경우가 있다.
		
		형식]
		
			[접근지정자] [속성] 데이터타입 함수이름(매개변수리스트) throws 예외클래스1, 예외클래스2, ...{
			
			}
			
		의미 ]
			지정한 예외가 발생하면 이 함수는 더이상 실행해도 의미가 없으므로 실행을 중지시킨다.
			
		*****
		예외가 전이된 함수는
		그 함수를 사용하는 곳에서 반드시 예외처리를 해줘야 한다.
		
		참고]
			==> 어떤 함수가 예외를 전이하는 함수라도
				예외처리를 하지 않아도 되는 경우가 있다.
				
				전이하는 예외가 RuntimeException의 하위인 경우에는 예외처리를 해도 그만, 안해도 그만 이다.
				(주로 java.lang 패키지 소속 클래스에 있는 함수들중 이런 함수들이 많이 존재한다.)
				
				하지만 가능하면 작성 해주는 것이 좋다.
		
================================================================================

Object 클래스

	==> 자바로 만든 클래스의 최상위 클래스 역할을 하는 클래스
		자바 상속 관계를 명확하게 하기 위한 역활을 주로 하는 클래스
		
	1. equals()
		==> 비교함수이다.
			문제는 Object가 가지고 있는 이 함수는
			내용을 비교하는 함수가 아니고
			주소를 비교하는 함수이다.
			
		참고]
			우리가 String 클래스의 equals 함수를 사용해서 문자열 데이터를 비교하기 때문에
			이 함수를 내용 비교 함수로 알고 있지만
			이것은 String 클래스가 Object 클래스의 equals 함수를 오버라이드하였기 때문에
			문자열의 데이터 비교 기능을 갖은 함수로 사용할 수있다.
			따라서
				Object.equals() 와 String.equals()의 차이점을 명확하게 구분해야 할 것이다.
				
		참고]
			만약 우리가 만드는 클래스도 내용 비교를 하도록 원하면
			이 함수를 오버라이드해서 기능을 수정하면 될 것이다.
		
					
----------------------------------------------------------------------------------

문제 2]

	삼각형 클래스를 작성하고
	
	삼각형 클래스의 밑변과 높이를 입력해서 객체를 만들도록 작성하고
	만약 밑변이 같으면 같은 삼각형이 되도록
	equals(), toStirng() 함수를 오버라이드하고
	테스트 하세요.
	
	입출력은 JOptionPane소속의 함수로 처라하세요.
	추가로 예외처리도 해주세요.		
		
		
		
		
		
		
		
		
		
		
		
		
		
			
	  